
## [Rust 死灵书](https://learnku.com/docs/nomicon/2018/31-reference/4712)

异常安全(exception-safety)
指针别名(pointer aliasing)
内存模型(memory model)
类型理论(type-theory)

释放后引用(use-after-free)

* 非安全Rust能够做什么？

1. 解引用裸指针
2. 调用非安全函数（包括C语言函数，编译器内联函数，还有直接内存分配等）
3. 实现非安全 trait
4. 访问或修改可变静态变量

与 C 不同，Rust 充分限制了可能出现的未定义行为的种类。语言核心只需要防止这几种行为：
1. 解引用null指针，悬垂指针，或者未赋值的指针
2. 读取未初始化的内存
3. 破坏指针混淆规则
4. 创建非法的基本类型
    * 悬垂引用与 null 引用
    * 空的 fn 指针
    * 0 和 1 以外的 bool 类型值
    * 未定义的枚举类型的项
    * 在 `[0x0,0xD&FF]` 和 `[0xE000, 0x10FFFF]` 以外的 char 类型值
    * 非 utf-8 编码的 str
5. 不谨慎地调用其他语言
6. 数据竞争

Rust 对于一些模糊的操作则通常比较宽容。Rust 会认为下列操作是安全的：

* 死锁
* 竞争条件
* 内存泄漏
* 调用析构函数失败
* 整型值溢出
* 终止程序
* 删除产品数据库

## 数据布局

### repr(Rust)

首先，每种类型都有一个数据对齐属性 (alignment)。一种类型的对齐属性决定了哪些内存地址可以合法地存储该类型的值。如果对齐属性是 n，那么它的值的存储地址必须是 n 的倍数。所以，对齐属性 2 表示值只能存储在偶数地址里，1 表示值可以存储在任何的地方。对齐属性最小为 1，并且永远是 2 的整数次幂。虽然不同平台的行为可能会不同，但大部分情况下基础类型都是按照它的类型大小对齐的。特别的是，在 x86 平台上 u64 和 f64 都是按照 32 位对齐的。

一种类型的大小都是它对齐属性的整数倍，这保证了这种类型的值在数组中的偏移量都是其类型尺寸的整数倍，可以按照偏移量进行索引。需要注意的是，动态尺寸类型的大小和对齐可能无法静态获取。

Rust 有如下几种复合类型

* 结构体 (带命名的复合类型 named product types)
* 元组 (匿名的复合类型 anonymous product types)
* 数组 (同类型数据集合 homogeneous product types)
* 枚举 (带命名的标签联合体 named sum types -- tagged unions)

### 类型中的奇行种

**动态尺寸类型 (DST, Dynamically Sized Type) ** 

Rust 支持动态尺寸类型，即不能静态获取尺寸或对齐属性的类型。乍一看，这事有点荒谬 ——Rust 必须知道一种类型的大小和对齐方式才能正确地使用它啊！从这一点来看，DST 不是一个普通的类型。由于类型大小是未知的，只能通过某种指针来访问它。所以，一个指向 DST 的指针是一个 “胖” 指针，它包含指针本身和一些额外的信息（具体请往下看）。

语言提供了两种主要的 DST：trait 对象和 slice。



### 所有权

引用

有两种引用的类型

* 共享指针：&
* 可变指针：&mut

它们遵守以下的规则

* 引用的生命周期不能超过被引用内容
* 可变引用不能存在别名(alias)



子类型和变性



### 资源管理

基于所有权的资源管理

OBRM（又被称为RAII：Resource Acquisition is Initialization，资源获取即初始化）

如果要获取资源，你只要创建一个管理它的对象。如果要释放资源，你只要销毁这个对象，由对象负责为你回收资源。而所谓资源通常指的就是内存。Box，Rc，以及 std::collections 中几乎所有的东西都是为了方便且正确地管理内存而存在的。这对于 Rust 尤为重要，因为我们并没有垃圾回收器帮我们管理内存。关键点就在这：Rust 要掌控一切。不过我们并不是只能管理内存。差不多所有的系统资源，比如线程、文件、还有 socket，都可以用到这些 API。







